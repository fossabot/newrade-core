import { GatsbyNode } from 'gatsby';

import { TsconfigPathsPlugin } from 'tsconfig-paths-webpack-plugin';
import { Configuration, ProgressPlugin, RuleSetRule } from 'webpack';

import { DEPLOY_ENV } from '@newrade/core-common';
import { CommonEnvType } from '@newrade/core-utils';
import {
  getBundleVisualizerPlugin,
  getForkTsCheckerWebpackPlugin,
  getLodashPlugin,
  getSizePlugin,
  getTypescriptBabelReactLoader,
  getWebpackStatsPlugin,
  stats,
} from '@newrade/core-webpack-config';

import { GatsbyCorePluginOptions } from '../gatsby-plugin-options';

/**
 * Replacement config for Gatsby's default config
 *
 * @see 'node_modules/gatsby/dist/utils/webpack.config.js'
 * @see https://webpack.js.org/configuration/
 */
export const onCreateWebpackConfigFunction: GatsbyNode['onCreateWebpackConfig'] = (
  { stage, rules, loaders, plugins, actions, getConfig, reporter, store },
  options
) => {
  const pluginOptions = options as unknown as GatsbyCorePluginOptions;

  /**
   *
   * Prepare env and gatsby stage information
   *
   */

  const env = process.env as CommonEnvType;
  const isProduction = process.env.NODE_ENV === 'production';
  const isDevelopStage = stage === 'develop';
  const isDevelopSSRStage = stage === 'develop-html';
  const isBuildJavaScriptStage = stage === 'build-javascript';
  const isSSRStage = stage === 'build-html';

  /**
   * Retrieve the initial gatsby webpack config
   */
  const config = getConfig() as Configuration;

  if (!config) {
    return void 0;
  }

  /**
   * Print out env information
   */
  reporter.info(
    `[${pluginOptions.pluginName}] process.env.TS_NODE_PROJECT: ${process.env.TS_NODE_PROJECT}`
  );
  if (process.env.TS_NODE_PROJECT) {
    delete process.env.TS_NODE_PROJECT; // avoid using external tsconfig for ts-loader or other tools
  }

  reporter.info(`[${pluginOptions.pluginName}] NODE_ENV: ${env.NODE_ENV}`);

  /**
   * Replace the devtool option
   *
   * @see https://webpack.js.org/configuration/devtool/#devtool
   */
  config.devtool = isProduction ? false : 'eval-cheap-module-source-map';

  /**
   * Remove es5 target
   */
  config.target = ['web'];

  /**
   * Enable `module` in mainfields
   */
  config.resolve = {
    ...config.resolve,
    mainFields: ['browser', 'module', 'main'],
  };

  /**
   * Custom settings for watchOptions
   */
  config.watchOptions = {
    ...config.watchOptions,
    ignored: ['*.d.ts', '*.js.map', '**/node_modules', '**/dist', 'graphql-types.ts'],
  };

  /**
   * Configure stats for webpack
   */
  if (env.APP_ENV === DEPLOY_ENV.LOCAL) {
    config.stats = {
      ...(typeof config.stats === 'object' ? config.stats : {}),
      ...stats.dev,
    };
  }

  if (isProduction) {
    config.stats = {
      ...stats.prod,
    };
  }

  /**
   * Add webpack stats plugin in production
   */
  if (isProduction) {
    config.plugins?.push(getWebpackStatsPlugin());
  }

  /**
   * Alias for core-js
   *
   * This is needed since gatsby uses only core-js and not the pure version
   */
  config.resolve = {
    ...config.resolve,
    alias: {
      ...(config.resolve && typeof config.resolve.alias === 'object' ? config.resolve.alias : {}),
      'core-js-pure': 'core-js',
    },
  };

  /**
   * Replace CSS rules
   */

  const cssRule = rules.css() as RuleSetRule;

  // reporter.info(`[${pluginOptions.pluginName}] current css rule:`);
  // printOutRules([cssRule]);
  // cssRule.exclude = /\.vanilla\.css$/i;
  // if (config.module?.rules) {
  //   reporter.info(`[${pluginOptions.pluginName}] adding loader for vanilla-extract .css files`);
  //   (config.module.rules as RuleSetRule[]) = [
  //     ...(config.module.rules as RuleSetRule[]),
  //     {
  //       test: /\.vanilla\.css$/i, // Targets only CSS files generated by vanilla-extract
  //       use: [
  //         loaders.miniCssExtract(),
  //         {
  //           loader: require.resolve('css-loader'),
  //           options: {
  //             url: false, // Required as image imports should be handled via JS/TS import statements
  //           },
  //         },
  //       ],
  //     },
  //   ];
  // }
  // reporter.info(`[${pluginOptions.pluginName}] updated css rule:`);
  // printOutRules([cssRule]);

  /**
   * Filters to find the correct webpack rules
   */

  const babelLoaderPredicate = (rule: RuleSetRule) =>
    String(rule.test) === '/\\.(js|mjs|jsx)$/' ||
    String(rule.test) === '/\\.(js|mjs)$/' || // since gatsby v3
    String(rule.test) === '/\\.js$/i' || // since gatsby v3
    String(rule.test) === '/\\.mjs$/i'; // since gatsby v3
  const negateBabelLoaderPredicate = (rule: RuleSetRule | '...') =>
    !babelLoaderPredicate(rule as RuleSetRule);

  /**
   * Add exclusions to .js/.mjs rules
   *
   * @see https://github.com/gatsbyjs/gatsby/blob/master/packages/babel-preset-gatsby/src/dependencies.ts
   */

  if (config.module?.rules) {
    reporter.info(
      `[${pluginOptions.pluginName}] adding exclusions to .js rules to exclude .css.ts and .css.js files`
    );
    reporter.info(`[${pluginOptions.pluginName}] current rules: `);
    printOutRules(config.module.rules);

    (config.module.rules as RuleSetRule[]) = [
      ...(config.module.rules as RuleSetRule[]).filter(babelLoaderPredicate).map((rule) => {
        if (rule) {
          const excludePattern = /\.css\.ts$|\.css\.js$|\.tsx$|\.ts$/i;
          if (rule.exclude) {
            rule.exclude = [rule.exclude, excludePattern];
            return rule;
          }
          rule.exclude = excludePattern;
        }
        return rule;
      }),
      ...(config.module.rules as RuleSetRule[]).filter(negateBabelLoaderPredicate),
    ] as RuleSetRule[];

    reporter.info(`[${pluginOptions.pluginName}] updated rules:`);
    printOutRules(config.module.rules);
  }

  /**
   * Replace Gatsby default babel config
   *
   * @see https://github.com/gatsbyjs/gatsby/blob/master/packages/babel-preset-gatsby/src/dependencies.ts
   */

  //  const moduleToParseByBabel = [
  //   'gatsby-plugin-image',
  //   ...(pluginOptions.modules ? pluginOptions.modules : []),
  // ];

  // if (config.module?.rules) {
  //   reporter.info(`[${pluginOptions.pluginName}]removing built-in rules for js/mjs/jsx`);
  //   config.module.rules = [
  //     // ...config.module.rules.filter(negateBabelLoaderPredicate),
  //     {
  //       ...getBabelReactLoader({ hmr: isDevelopStage }),
  //       test: /\.[jt]sx?$/,
  //       // whitelist specific es6 modules
  //       exclude: (modulePath: string) =>
  //         /node_modules/.test(modulePath) &&
  //         !new RegExp(
  //           `[\\\\/](${moduleToParseByBabel
  //             .map((module) => module.replace(/\//, path.sep))
  //             .map(regexEscape)
  //             .join('|')})[\\\\/]`
  //         ).test(modulePath),
  //     },
  //   ];
  // }

  /**
   *
   * Add tsx support with ts-loader
   *
   */

  const tsLoaderPredicate = (rule: RuleSetRule) => String(rule.test) === '/\\.tsx?$/';
  const negateTsLoaderPredicate = (rule: RuleSetRule) => !tsLoaderPredicate(rule);

  if (config.module?.rules) {
    reporter.info(`[${pluginOptions.pluginName}] adding .tsx file support`);
    reporter.info(`[${pluginOptions.pluginName}] current rules: `);
    printOutRules(config.module.rules);

    (config.module.rules as RuleSetRule[]) = [
      ...(config.module.rules as RuleSetRule[]).filter(negateTsLoaderPredicate),
      getTypescriptBabelReactLoader({
        isDevelopment: isDevelopStage,
        tsLoaderOptions: {
          projectReferences: false,
          compilerOptions: {
            declaration: false,
            composite: false,
            incremental: false,
          },
        },
        babelPlugins: [['@vanilla-extract/babel-plugin']],
      }),
    ] as RuleSetRule[];

    reporter.info(`[${pluginOptions.pluginName}] updated rules:`);
    printOutRules(config.module.rules);

    reporter.info(`[${pluginOptions.pluginName}] adding fork-ts-checker-webpack-plugin`);
    config.plugins?.push(getForkTsCheckerWebpackPlugin());

    // can be used to counter tsc emitting all files again but it's slower for the first webpack build
    // config.snapshot = {
    //   module: {
    //     timestamp: true,
    //     hash: true,
    //   },
    // };
  }

  /**
   *
   * Updating resolve, aliases, plugins and etc.
   *
   */

  // add tsconfig path to webpack aliases
  config.resolve = {
    ...config.resolve,
    alias: {
      ...config.resolve?.alias,
    },
    extensions: ['.js', '.json', '.wasm', '.ts', '.jsx', '.tsx'],
    plugins: [
      ...(config.resolve?.plugins || []),
      new TsconfigPathsPlugin({
        configFile: 'tsconfig.json',
        logLevel: 'INFO',
        logInfoToStdOut: true,
        extensions: ['.js', '.json', '.wasm', '.ts', '.jsx', '.tsx'],
      }),
    ],
  };

  /**
   * Avoid parsing react and react-dom
   */
  // config.module = {
  //   ...config.module,
  //   noParse: /node_modules\/(react|react-dom)\//,
  // };

  /**
   * Add BundleVisualizer when building for production & local only
   */
  if (isProduction && env.APP_ENV === DEPLOY_ENV.LOCAL) {
    reporter.info(`[${pluginOptions.pluginName}] adding bundle visualizer plugin`);
    config.plugins = config.plugins
      ? [...config.plugins, getBundleVisualizerPlugin()]
      : [getBundleVisualizerPlugin()];
  }

  /**
   * Add SizePlugin
   */
  if (isProduction) {
    reporter.info(`[${pluginOptions.pluginName}] adding size-plugin plugin`);
    config.plugins = [...(config.plugins || []), getSizePlugin()];
  }

  /**
   * Add ProgressPlugin, only for development
   */
  if (!isProduction || env.APP_ENV === DEPLOY_ENV.LOCAL) {
    reporter.info(`[${pluginOptions.pluginName}] adding progress plugin`);
    config.plugins = [
      ...(config.plugins || []),
      new ProgressPlugin({
        activeModules: false,
      }),
    ];
  }

  /**
   * Add lodash plugin
   */
  config.plugins?.push(getLodashPlugin());
  config.resolve = {
    ...config.resolve,
    alias: {
      ...(config.resolve && typeof config.resolve.alias === 'object' ? config.resolve.alias : {}),
      lodash: 'lodash-es',
    },
  };

  //
  // completely replace the webpack config with the modified one
  //
  reporter.info(`[${pluginOptions.pluginName}] replacing webpack config with modified one`);
  actions.replaceWebpackConfig(config);

  /**
   *
   * Utilities below
   *
   */

  function printOutRules(rules: (RuleSetRule | '...')[]) {
    (rules as RuleSetRule[])
      .filter((rule) => !!rule)
      .forEach((rule) => {
        reporter.info(`[${pluginOptions.pluginName}] rule: ${rule.test}, exclude: ${rule.exclude}`);
      });
  }
};
